#!/usr/bin/env ruby
# encoding: UTF-8

require_relative '../lib/wf/cli'

class WF
  class << self
    # LOCAL_PREFIX = 'feature/'

# CMD
    # def run_cops
    #   need_fix_style = ruby_changed_files
    #   if need_fix_style.empty?
    #     true
    #   else
    #     loop do
    #       log "Run cops"
    #       res = `rubocop -a -R "#{need_fix_style.join('" "')}"`
    #       log res
    #       state = RES_PARSE_RE.match(res)
    #       if state[:offenses].to_i == state[:corrections].to_i
    #         break
    #       else
    #         log "Cops fails!!!\n Press enter to continue."
    #         $stdin.gets
    #       end
    #     end
    #   end
    # end


# TASK
    # def start(args)
    #   task = args[0]
    #   log "FOR TASK #{task}:"
    #   target_branch, args = extract_target_param args[1..-1]
    #   status = set_phase
    #   push args, status
    #   switch_to_task task, target_branch
    # end

    # def push(args = [], status = '#in-progress')
    #   if in_wf_branch
    #     if uncommited? && commit?(args)
    #       commit! get_comment(args[1], "#{env_task} #{status} ")
    #     end
    #     push_task env_task
    #   end
    # end

    # def update
    #   if in_wf_branch
    #     pull "master"
    #     pull_task env_task
    #   end
    # end

    # def close(args)
    #   target_branch, args = extract_target_param args
    #   push args, '#resolve-issue'
    #   if hub_check?
    #     `hub pull-request -m "#{env_task} close" -b "#{target_branch}"`
    #   elsif boolean_ask("Hub don't installed.\nCommit direct to #{target_branch}?")
    #     switch_to target_branch
    #     pull_task env_task
    #     `git push`
    #   end
    #   set_env_task nil
    # end

    # def exit
    #   set_env_task nil
    #   target_branch, args = extract_target_param []
    #   switch_to target_branch
    # end


# GITHUB
    # def hub_check?
    #   !system('hub --version').nil?
    # end

# DEPLOY
    # def deploy
    #   return puts('Установите переменную среды PROD_NAME') unless ENV['PROD_NAME']
    #   return puts('Установите переменную среды PROD_PASS') unless ENV['PROD_PASS']
    #   finished = ("%08x" * 8) % Array.new(8) { rand(0xFFFFFFFF) }
    #   password = ENV['PROD_PASS']
    #   Net::SSH.start('10.100.0.111', ENV['PROD_NAME'], password: password, port: 60022) do |ssh|
    #     sign_in = false
    #     remote_call = ->(channel, data, &block) do
    #       puts data
    #       if data =~ /\[sudo\]/
    #         channel.send_data(password + "\n")
    #         sign_in = true
    #       elsif data.include?(finished) || sign_in
    #         sign_in = false
    #         block.call
    #       end
    #     end
    #     su = ->(user, commands, &block) do
    #       channel_ = ssh.open_channel do |channel|
    #         channel.request_pty(modes: { Net::SSH::Connection::Term::ECHO => 0 }) do |c, success|
    #           next unless success
    #           sign_in = false
    #           c.exec("sudo su #{user}") do |sudo_channel, sudo_success|
    #             if sudo_success
    #               channel.on_data do |ondata_channel, data|
    #                 remote_call.call(channel, data) do |output|
    #                   cmd = commands.shift
    #                   if cmd
    #                     puts "#{user}:$> #{cmd}"
    #                     cmd = "#{cmd}; echo #{finished}\n"
    #                     channel.send_data(cmd)
    #                   else
    #                     if block
    #                       block.call channel 
    #                     else
    #                       channel.do_close
    #                     end
    #                   end
    #                 end
    #               end
    #               channel.on_close do |onclose_channel|
    #                 puts "Channel closed."
    #               end
    #             end
    #           end
    #         end
    #       end
    #     end

    #     su.call(:bckp_usr, [
    #       '~/backup.sh'
    #     ]) do |bckp_usr|
    #       bckp_usr.do_close
    #       su.call(:rubyuser, [
    #         'cd /opt/obruset',
    #         'ruby wf deploy_local',
    #         'touch tmp/restart.txt',
    #       ]) do |rubyuser|
    #         rubyuser.do_close
    #         ssh.close
    #       end
    #     end
    #   end
    # end

    # def deploy_local
    #   log "Deploy local"
    #   prev_commit = `git rev-parse HEAD`.chomp
    #   log "git pull..."
    #   pull current_branch
    #   files = `git diff --name-only #{prev_commit}`.split($INPUT_RECORD_SEPARATOR)
    #   log "bundle install..."
    #   `bundle install --without=development test` if files.any?{|f| f =~ /Gemfile(\.lock)?/ }
    #   log "rake db:migrate..."
    #   `rake db:migrate RAILS_ENV=production` if files.any?{|f| f =~ /db\/migrate\/.*\.rb/ }
    #   log "localeapp pull..."
    #   `localeapp pull`
    #   log "rake assets:precompile..."
    #   `rake assets:precompile RAILS_ENV=production` if files.any?{|f| f =~ /app\/assets/ }
    #   log "rake tmp:cache:clear..."
    #   `nohup rake tmp:cache:clear RAILS_ENV=production > /dev/null &`
    #   log "rake ts..."
    #   `nohup rake ts:stop ts:index ts:start RAILS_ENV=production > /dev/null &`
    #   log "sidekiq..."
    #   `nohup service sidekiq restart > /dev/null &`
    #   log "Deploy local: OK!"
    # end

# GIT
    # def pull_from_remote
    #   pull current_branch
    # end


# STRUCT

    # def pr_update(args)
    #   task = args.first
    #   args = args[1..-1]
    #   pr = "feature/#{task}"
    #   in_branch pr do
    #     target_branch, args = extract_target_param args
    #     with_merged target_branch do
    #       `rake db:migrate` if boolean_ask "Update schema?"
    #       `git push origin #{pr}`
    #     end
    #   end
    # end

    # def pr_updates
    #   github_open_pull_requests.each do |pr|
    #     in_branch pr.head.ref do
    #       with_merged pr.base.ref do
    #         `git push origin #{pr.head.ref}`
    #       end
    #     end
    #   end
    # end

    # def pr_merge(args)
    #   number = args[0]
    #   pr = github_pull_request number
    #   if pr
    #     if pr.merged
    #       log "PR #{number} already merged"
    #     else
    #       github_pull_request_merge number
    #       tree_update
    #       log "PR #{number} merged"
    #     end
    #   else
    #     log "PR #{number} not found"
    #   end
    # end

    # def pr_list
    #   github_open_pull_requests.each do |pr|
    #     log "#{pr.number} :: #{pr.base.ref} < #{pr.head.ref}  : #{pr.title}"
    #   end
    # end

    # def tree_update
    #   update_queue = branch_subtree_for('hotfix') + branch_subtree_for('release') + [:master]
    #   update_queue.each_cons(2) do |up, down|
    #     in_branch down do
    #       with_merged up do
    #         `git push origin #{down}`
    #       end
    #     end
    #   end
    #   pr_updates if boolean_ask 'Update Pull requests?'
    # end

    # def release_hotfix(args)
    #   version = args.first
    #   args = args[1..-1]
    #   hotfix = "hotfix/#{version}"

    #   restore_stash = true if uncommited?
    #   in_branch hotfix do
    #     if restore_stash
    #       `git stash apply`
    #       commit! get_comment(args[1]) if commit?(args)
    #     end
    #     `git push origin "#{hotfix}"`
    #     log "Create tag"
    #     `git tag -a v#{version} -m 'hotfix version #{version}'`
    #     in_branch "master" do
    #       with_merged hotfix do
    #         `git push origin master`
    #       end
    #     end
    #     in_branch "stable" do
    #       with_merged hotfix do
    #         `git push origin stable`
    #       end
    #     end
    #     # `git push origin --delete #{hotfix}`
    #   end
    # end

    # def release_open(args)
    #   cmd, version = *args
    #   version = cmd if cmd != 'open'

    #   release = "release/#{version}"
    #   in_branch "master" do
    #     in_branch release do
    #       with_merged 'master' do
    #         `git push origin "#{release}"`
    #       end
    #     end
    #   end
    # end

    # def release_close(args)
    #   version = args.first
    #   release = "release/#{version}"
    #   in_branch "master" do
    #     in_branch release do
    #       `git push origin "#{release}"`
    #       log "Create tag"
    #       `git tag -a v#{version} -m 'release version #{version}'`
    #       in_branch "master" do
    #         log "Merge master"
    #         with_merged release do
    #           `git push origin master`
    #         end
    #       end
    #       in_branch "stable" do
    #         log "Merge stable"
    #         with_merged release do
    #           `git push origin stable`
    #         end
    #       end
    #       `git push origin --delete #{release}`
    #     end
    #   end
    # end

# Install
    # def install
    #   log "Install for linux-amd64"
    #   `mkdir tmp`
    #   Dir.chdir('tmp') do
    #     `wget https://github.com/github/hub/releases/download/v2.2.1/hub-linux-amd64-2.2.1.tar.gz`
    #     `tar -xzf hub-linux-amd64-2.2.1.tar.gz`
    #     `rm hub-linux-amd64-2.2.1.tar.gz`
    #     Dir.chdir('hub-linux-amd64-2.2.1') do
    #       log "sudo cp hub /usr/local/bin/hub"
    #       `sudo cp hub /usr/local/bin/hub`
    #     end
    #   end
    # end

    protected

# STRUCT
    # def last_hotfix
    #   branch_subtree_for('hotfix').last
    # end

    # def last_release
    #   branch_subtree_for('release').last
    # end

# TASK
    # def set_phase
    #   if in_wf_branch
    #     log "You are leaving #{env_task}"
    #     state = nil
    #     while !state
    #       log "What is state of the task? (s/r/?)"
    #       state = case $stdin.gets
    #                 when /s/ then
    #                   '#stop-progress'
    #                 when /r/ then
    #                   '#resolve-issue'
    #                 else
    #                   log 'Choose next one: s - stop, r - resolve'
    #                   nil
    #               end
    #     end
    #     state
    #   end
    # end

    # def extract_target_param(args)
    #   target_branch = case args.first
    #                     when 'hotfix', 'h'
    #                       args = args[1..-1]
    #                       last_hotfix
    #                     when 'master', 'm'
    #                       args = args[1..-1]
    #                       :master
    #                     else
    #                       answer = ask_for_valid "Select base branch", "(m/h/r)", /m(aster)?|h(otfix)?|r(elease)?/i
    #                       case answer
    #                         when /h(otfix)?/i
    #                           last_hotfix
    #                         when /r(elease)?/i
    #                           last_release
    #                         else
    #                           :master
    #                       end
    #                   end
    #   log "Base on: #{target_branch}"
    #   [target_branch, args]
    # end

    # def switch_to_task(task, start_point = :master)
    #   switch_to "#{LOCAL_PREFIX}#{task}", start_point
    #   pull_task task
    #   set_env_task task
    # end

    # def set_env_task(task)
    #   File.write('.wf', JSON.dump(task))
    # end

    # def env_task
    #   JSON.load(File.read('.wf'))
    # rescue
    #   nil
    # end

    # def push_task(task)
    #   `git push origin "#{LOCAL_PREFIX}#{task}":"feature/#{task}"`
    # end

    # def pull_task(task)
    #   pull "feature/#{task}"
    # end

    # def in_wf_branch
    #   env_task && status[0].index(env_task)
    # end
    # def commit?(args)
    #   params_to_commit?(args) || ask_to_commit
    # end

    # def params_to_commit?(args)
    #   %w(c commit).include? args[0]
    # end

# GIT
    # def switch_to(branch, start_point = nil, opts = nil)
    #   unless branch?(branch)
    #     start_point = current_branch unless start_point
    #     in_branch start_point do
    #       __switch_to branch, "#{opts} -b "
    #     end
    #   end
    #   __switch_to branch, opts
    #   log "Current branch: #{branch}"
    # end

    # def __switch_to(branch, opts = nil)
    #   while !system("git checkout #{opts} #{branch}")
    #     log "Can't switch branch to #{branch} untill changes apply:"
    #     puts status[1..-1].join("\n")
    #     log "Please fix you changes and do next:"
    #     answer = ask_for_valid "commit or stash changes?", "(c/s)", /c(ommit)?|s(tash)?/i
    #     if answer =~ /c(ommit)?/i
    #       commit! get_comment
    #     else
    #       `git stash`
    #     end
    #   end
    #   pull branch
    # end

    # def branch_subtree_for(prefix)
    #   branch_subtree = exec_output_list %{git branch -a --list "#{prefix}/*"}
      
    #   branch_subtree.sort_by { |a| a.split('/').last.split('.').map(&:to_i) }
    # end    

    # # парсинг вывода git комнад
    # def exec_output_list(cmd)
    #   output = `#{cmd}`
    #   output.split("\n").map do |line| 
    #     line.strip.sub('* ', '')
    #   end
    # end

    # def pull(remote_branch)
    #   result = nil
    #   output = ''
    #   io_r, io_w = IO.pipe
    #   pull_block = lambda do
    #     log %{git pull origin "#{remote_branch}"}
    #     result = system(%{git pull origin "#{remote_branch}"}, [:out, :err] => io_w)
    #     io_w.close
    #     output = io_r.read
    #   end
    #   loop do
    #     output = ''
    #     if uncommited?
    #       args = []
    #       if commit?(args)
    #         commit! get_comment
    #       else
    #         with_stash(&pull_block)
    #       end
    #     else
    #       pull_block[]
    #     end
    #     return if result || output =~ /Couldn't find remote ref/
    #   end
    # end

    # def status
    #   `git status -b -s`.split("\n")
    # end

    # def current_branch
    #   `git rev-parse --abbrev-ref HEAD`.split("\n")[0]
    # end

    # def branch?(name)
    #   `git branch --list "#{name}"`.size > 0
    # end

    # def in_branch(branch)
    #   return_to = current_branch
    #   return yield if return_to == branch

    #   with_stash do
    #     switch_to branch
    #     yield
    #     switch_to return_to
    #   end
    # end

    # def with_stash
    #   if uncommited?
    #     `git stash`
    #     yield
    #     `git stash pop`
    #   else
    #     yield
    #   end
    # end

    # def with_merged(branch)
    #   msg = "Merge branch #{branch} into #{current_branch}"
    #   log msg
    #   commit! get_comment([], msg) while !system(%{git merge "#{branch}" --no-edit})
    #   yield
    # end

    # def uncommited?
    #   status.size > 1
    # end

    # def check_conflicts!
    #   loop do
    #     conflicts = `git diff --name-only --diff-filter=U`
    #     return if conflicts == ''
    #     log "Resolve conflicts and continue?\n#{conflicts}"
    #     answer = ask_for_valid "Press Continue then finish?", "(C)", /c(ontinue)?/i
    #   end
    # end

    # def commit!(msg)
    #   log "Current task: #{env_task}" if env_task
    #   check_conflicts!
    #   run_cops
    #   `git add .`
    #   `git commit -a -m "#{msg}"`
    # end

    # def ask_to_commit
    #   log "Changes"
    #   puts status[1..-1].join("\n")
    #   boolean_ask "Commit?"
    # end

    # def changed_files
    #   status[1..-1].map { |line| line[3..-1] }
    # end

    # def ruby_changed_files
    #   changed_files.select { |path| path =~ /(\.rb|\.rake)\z/i }
    # end

    # def get_comment(args = [], prefix = '')
    #   "#{prefix}#{args[1] || ask_comment(prefix)}"
    # end

    # def ask_comment(prefix = '')
    #   log "Comment for commit: #{prefix}"
    #   $stdin.gets
    # end

# CMD
    # def boolean_ask(msg)
    #   answer = ask_for_valid msg, "(y/n)", /y(es)?|да|n(o)?|нет/i
    #   answer =~ /y(es)?|да/i
    # end

    # def ask_for_valid(msg, offer, validator)
    #   loop do
    #     log "#{msg} #{offer}"
    #     answer = $stdin.gets
    #     return answer if answer =~ validator
    #   end
    # end



# LOGGER
    # def log(text)
    #   puts "[WF]: #{text}"
    # end


# GITHUB
    # def github
    #   raise 'Установите переменную среды GITHUB_BASIC_AUTH' unless ENV['GITHUB_BASIC_AUTH']
    #   @github = Github.new basic_auth: ENV['GITHUB_BASIC_AUTH']
    # end

    # def github_open_pull_requests
    #   github_pull_requests.list(state: 'open', auto_pagination: true)
    # end

    # def github_pull_request(number)
    #   github.pull_requests.get('uniwebru', 'Obruset', number.to_i)
    # end

    # def github_pull_requests
    #   github.pull_requests(user: 'uniwebru', repo: 'Obruset')
    # end

    # def github_pull_request_merge(number)
    #   github.pull_requests.merge('uniwebru', 'Obruset', number.to_i)
    # end
  end
end


Wf::Cli.start ARGV
